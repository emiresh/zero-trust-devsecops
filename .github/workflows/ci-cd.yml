name: CI/CD Pipeline - FreshBonds

on:
  push:
    branches:
      - main
    paths:
      - 'src/**'
      - 'apps/*/templates/**'
      - 'Dockerfile'
  pull_request:
    branches:
      - main
    paths:
      - 'src/**'
      - 'apps/*/templates/**'
      - 'Dockerfile'

permissions:
  contents: write          # Required for pushing manifest updates
  security-events: write   # Required for SARIF uploads
  packages: read
  pull-requests: write     # For PR comments

env:
  DOCKER_REGISTRY: docker.io
  DOCKER_USERNAME: ${{ secrets.DOCKER_USERNAME }}
  IMAGE_PREFIX: ${{ secrets.DOCKER_USERNAME }}

jobs:
  # ==========================================
  # STAGE 1: Detect Changes
  # ==========================================
  detect-changes:
    name: ðŸ” Detect Changed Services
    runs-on: ubuntu-latest
    outputs:
      services: ${{ steps.detect.outputs.services }}
      has_changes: ${{ steps.detect.outputs.has_changes }}
    
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Detect Changed Services
        id: detect
        run: |
          # Get changed files
          if [[ "${{ github.event_name }}" == "pull_request" ]]; then
            CHANGED_FILES=$(git diff --name-only origin/${{ github.base_ref }}...HEAD)
          else
            CHANGED_FILES=$(git diff --name-only HEAD~1 HEAD)
          fi
          
          echo "ðŸ“ Changed files:"
          echo "$CHANGED_FILES"
          echo ""
          
          # Initialize services array
          SERVICES=()
          
          # Check each service directory
          if echo "$CHANGED_FILES" | grep -q "^src/frontend/"; then
            SERVICES+=("frontend")
            echo "âœ… Detected: frontend"
          fi
          
          if echo "$CHANGED_FILES" | grep -q "^src/api-gateway/"; then
            SERVICES+=("api-gateway")
            echo "âœ… Detected: api-gateway"
          fi
          
          if echo "$CHANGED_FILES" | grep -q "^src/user-service/"; then
            SERVICES+=("user-service")
            echo "âœ… Detected: user-service"
          fi
          
          if echo "$CHANGED_FILES" | grep -q "^src/product-service/"; then
            SERVICES+=("product-service")
            echo "âœ… Detected: product-service"
          fi
          
          # If workflow or Dockerfile changed, rebuild all
          if echo "$CHANGED_FILES" | grep -qE "^(\.github/workflows/|Dockerfile)"; then
            echo "âš ï¸ Workflow or Dockerfile changed - rebuilding all services"
            SERVICES=("frontend" "api-gateway" "user-service" "product-service")
          fi
          
          # Create JSON array
          if [[ ${#SERVICES[@]} -eq 0 ]]; then
            echo "â„¹ï¸ No services to build"
            SERVICES_JSON="[]"
            HAS_CHANGES="false"
          else
            SERVICES_JSON="["
            for i in "${!SERVICES[@]}"; do
              if [[ $i -gt 0 ]]; then
                SERVICES_JSON+=","
              fi
              SERVICES_JSON+="\"${SERVICES[$i]}\""
            done
            SERVICES_JSON+="]"
            HAS_CHANGES="true"
          fi
          
          echo ""
          echo "ðŸŽ¯ Services to build: ${SERVICES[*]}"
          echo "ðŸ“Š JSON matrix: $SERVICES_JSON"
          
          # Validate JSON
          if ! echo "$SERVICES_JSON" | jq empty >/dev/null 2>&1; then
            echo "âŒ Invalid JSON, using fallback"
            SERVICES_JSON='[]'
            HAS_CHANGES="false"
          fi
          
          echo "services=$SERVICES_JSON" >> $GITHUB_OUTPUT
          echo "has_changes=$HAS_CHANGES" >> $GITHUB_OUTPUT

  # ==========================================
  # STAGE 2: Infrastructure Security & Compliance Validation
  # ==========================================
  policy-checks:
    name: ðŸ” Validate Infrastructure & Security Policies
    runs-on: ubuntu-latest
    needs: detect-changes
    if: needs.detect-changes.outputs.has_changes == 'true'
    
    permissions:
      contents: read
      security-events: write  # Required for uploading SARIF files
      actions: read           # Required for workflow run API access
    
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Validate Kubernetes Manifests with OPA (Policy-as-Code)
        if: hashFiles('policies/opa/**') != ''
        run: |
          echo "ðŸ” Validating Kubernetes manifests with OPA policies..."
          echo ""
          
          # Install Conftest
          CONFTEST_VERSION=0.63.0
          curl -sL https://github.com/open-policy-agent/conftest/releases/download/v${CONFTEST_VERSION}/conftest_${CONFTEST_VERSION}_Linux_x86_64.tar.gz | tar xz
          sudo mv conftest /usr/local/bin/
          
          # Install Helm
          curl -s https://raw.githubusercontent.com/helm/helm/main/scripts/get-helm-3 | bash > /dev/null 2>&1
          
          # Render and test Helm charts
          for chart in apps/*/; do
            if [[ -f "$chart/Chart.yaml" ]]; then
              chart_name=$(basename "$chart")
              echo "ðŸ“¦ Testing: $chart_name"
              
              # Render Helm template
              helm template "$chart_name" "$chart" > "/tmp/${chart_name}.yaml" 2>/dev/null || continue
              
              # Run OPA validation
              conftest test --policy ./policies/opa "/tmp/${chart_name}.yaml" > /tmp/results.txt 2>&1 || true
              
              # Show results
              cat /tmp/results.txt
              
              # Parse summary
              SUMMARY=$(tail -1 /tmp/results.txt)
              PASSED=$(echo "$SUMMARY" | grep -oP '\d+(?= passed)' || echo "0")
              WARNINGS=$(echo "$SUMMARY" | grep -oP '\d+(?= warnings)' || echo "0")
              FAILURES=$(echo "$SUMMARY" | grep -oP '\d+(?= failures)' || echo "0")
              
              # GitHub Summary
              cat >> $GITHUB_STEP_SUMMARY << EOF
          ## ðŸ” OPA Validation: $chart_name
          **Policy-as-Code:** Custom security rules and business logic validation
          
          | âœ… Passed | âš ï¸ Warnings | âŒ Failures |
          |-----------|-------------|-------------|
          | $PASSED | $WARNINGS | $FAILURES |
          
          <details>
          <summary>ðŸ“‹ View Details</summary>
          
          \`\`\`
          $(cat /tmp/results.txt)
          \`\`\`
          
          </details>
          
          EOF
              
              echo ""
            fi
          done
          
          echo "âœ… Validation completed"

      - name: Validate Kubernetes Manifests with Kyverno (Admission Control)
        if: hashFiles('policies/kyverno/**') != ''
        run: |
          echo "ðŸ›¡ï¸ Validating Kubernetes manifests with Kyverno policies..."
          echo ""
          
          # Install Kyverno CLI
          curl -LO https://github.com/kyverno/kyverno/releases/download/v1.11.0/kyverno-cli_v1.11.0_linux_x86_64.tar.gz
          tar -xzf kyverno-cli_v1.11.0_linux_x86_64.tar.gz
          sudo mv kyverno /usr/local/bin/
          rm kyverno-cli_v1.11.0_linux_x86_64.tar.gz
          
          # Install Helm
          curl -s https://raw.githubusercontent.com/helm/helm/main/scripts/get-helm-3 | bash > /dev/null 2>&1
          
          # Test Helm templates
          for chart in apps/*/; do
            if [[ -f "$chart/Chart.yaml" ]]; then
              chart_name=$(basename "$chart")
              echo "ðŸ“¦ Testing $chart_name with Kyverno..."
              
              helm template "$chart_name" "$chart" > "/tmp/${chart_name}.yaml" 2>/dev/null || continue
              
              # Apply Kyverno policies
              kyverno apply policies/kyverno/*.yaml --resource "/tmp/${chart_name}.yaml" > /tmp/kyverno-results.txt 2>&1 || true
              
              cat /tmp/kyverno-results.txt
              echo ""
              
              # Parse results from summary line (e.g., "pass: 28, fail: 0, warn: 0, error: 0, skip: 8")
              SUMMARY=$(grep -E "^pass:" /tmp/kyverno-results.txt || echo "pass: 0")
              PASSED=$(echo "$SUMMARY" | grep -oP 'pass:\s*\K\d+' || echo "0")
              FAILED=$(echo "$SUMMARY" | grep -oP 'fail:\s*\K\d+' || echo "0")
              WARNINGS=$(echo "$SUMMARY" | grep -oP 'warn:\s*\K\d+' || echo "0")
              SKIPPED=$(echo "$SUMMARY" | grep -oP 'skip:\s*\K\d+' || echo "0")
              
              # GitHub Summary
              cat >> $GITHUB_STEP_SUMMARY << EOF
          ## ðŸ›¡ï¸ Kyverno Validation: $chart_name
          **Admission Control:** Kubernetes Pod Security Standards enforcement
          
          | âœ… Passed | âŒ Failed | âš ï¸ Warnings | â­ï¸ Skipped |
          |-----------|----------|-------------|-----------|
          | $PASSED | $FAILED | $WARNINGS | $SKIPPED |
          
          <details>
          <summary>ðŸ“‹ View Details</summary>
          
          \`\`\`
          $(cat /tmp/kyverno-results.txt)
          \`\`\`
          
          </details>
          
          EOF
              echo ""
            fi
          done
          
          echo "âœ… Kyverno policy tests completed"

      - name: Scan Infrastructure as Code with Checkov (IaC Security)
        id: checkov
        continue-on-error: true  # Capture results even with failures
        run: |
          echo "Running Checkov IaC security scanning..."
          
          # Install checkov if not available
          pip install checkov >/dev/null 2>&1 || true
          
          # Run Checkov with both console and SARIF output
          checkov -d . \
            --framework kubernetes terraform dockerfile \
            --skip-check CKV_K8S_43,CKV_K8S_35 \
            --skip-path test-pod.yaml,test-pvc.yaml,Future/ \
            --output cli \
            --compact \
            2>&1 | tee /tmp/checkov-output.txt
          
          # Generate SARIF file separately for upload
          checkov -d . \
            --framework kubernetes terraform dockerfile \
            --skip-check CKV_K8S_43,CKV_K8S_35 \
            --skip-path test-pod.yaml,test-pvc.yaml,Future/ \
            --output sarif \
            --output-file-path . \
            >/dev/null 2>&1 || true
          
          # Store exit code
          CHECKOV_EXIT=$?
          
          # Parse the summary line - Checkov outputs like "Passed checks: 266, Failed checks: 3, Skipped checks: 0"
          SUMMARY=$(grep -E "^(kubernetes|terraform|dockerfile) scan results:" -A 2 /tmp/checkov-output.txt | tail -1)
          
          # Extract numbers - looking for pattern "Passed checks: X, Failed checks: Y, Skipped checks: Z"
          PASSED=$(echo "$SUMMARY" | grep -oP 'Passed checks:\s*\K\d+' || echo "0")
          FAILED=$(echo "$SUMMARY" | grep -oP 'Failed checks:\s*\K\d+' || echo "0")
          SKIPPED=$(echo "$SUMMARY" | grep -oP 'Skipped checks:\s*\K\d+' || echo "0")
          
          # Fallback: if parsing failed, try to count from full output
          if [ "$PASSED" = "0" ] && [ "$FAILED" = "0" ]; then
            PASSED=$(grep -c "Check: CKV" /tmp/checkov-output.txt 2>/dev/null || echo "0")
            FAILED=$(grep -c "FAILED for resource:" /tmp/checkov-output.txt 2>/dev/null || echo "0")
          fi
          
          # Output for next step
          echo "CHECKOV_PASSED=$PASSED" >> $GITHUB_OUTPUT
          echo "CHECKOV_FAILED=$FAILED" >> $GITHUB_OUTPUT
          echo "CHECKOV_SKIPPED=$SKIPPED" >> $GITHUB_OUTPUT
          
          # GitHub Summary
          cat >> $GITHUB_STEP_SUMMARY << EOF
          ## ðŸ” Checkov IaC Security Scanning
          **Infrastructure as Code:** Kubernetes, Terraform, and Dockerfile security validation
          
          | âœ… Passed | âŒ Failed | â­ï¸ Skipped |
          |----------|---------|-----------|
          | $PASSED | $FAILED | $SKIPPED |
          
          EOF
          
          if [ "$FAILED" -gt "0" ]; then
            echo "âš ï¸ **Action Required:** $FAILED security issues found!" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "Review the detailed output above for specific violations and remediation guidance." >> $GITHUB_STEP_SUMMARY
            exit 1
          else
            echo "âœ… All Checkov security checks passed!" >> $GITHUB_STEP_SUMMARY
          fi

      - name: Upload Checkov Results as Artifact
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: checkov-sarif-results
          path: results_sarif.sarif
          retention-days: 30

  # ==========================================
  # STAGE 3: Build, Test, Scan, Push
  # ==========================================
  build-and-scan:
    name: ðŸ—ï¸ Build ${{ matrix.service }}
    runs-on: ubuntu-latest
    needs: [detect-changes, policy-checks]
    if: |
      always() &&
      needs.detect-changes.outputs.has_changes == 'true' &&
      (needs.policy-checks.result == 'success' || needs.policy-checks.result == 'skipped')
    
    permissions:
      contents: read
      packages: write
      security-events: write
    
    strategy:
      fail-fast: false
      matrix:
        service: ${{ fromJSON(needs.detect-changes.outputs.services) }}
    
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Set up QEMU (for ARM64 emulation)
        uses: docker/setup-qemu-action@v3
        with:
          platforms: arm64

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}

      - name: Generate Image Tag
        id: meta
        run: |
          SHORT_SHA=$(echo ${{ github.sha }} | cut -c1-7)
          TIMESTAMP=$(date +%Y%m%d-%H%M%S)
          
          # Generate semantic version tag
          if [[ "${{ github.ref }}" == "refs/heads/main" ]]; then
            TAG="v1.0.${GITHUB_RUN_NUMBER}"
          else
            TAG="dev-${SHORT_SHA}"
          fi
          
          echo "tag=$TAG" >> $GITHUB_OUTPUT
          echo "short_sha=$SHORT_SHA" >> $GITHUB_OUTPUT
          echo "timestamp=$TIMESTAMP" >> $GITHUB_OUTPUT
          
          echo "ðŸ“¦ Image Tag: $TAG"

      - name: Build Images (Optimized Strategy)
        id: build
        run: |
          SERVICE="${{ matrix.service }}"
          TAG="${{ steps.meta.outputs.tag }}"
          IMAGE_NAME="${{ env.IMAGE_PREFIX }}/freshbonds-${SERVICE}"
          
          if [[ "$SERVICE" == "frontend" ]]; then
            # Frontend: Build AMD64 first for scanning, then multi-arch
            echo "ðŸ—ï¸ Building frontend AMD64 for scanning..."
            
            docker buildx build \
              --platform linux/amd64 \
              --build-arg VITE_API_URL=/api \
              --load \
              -t "${IMAGE_NAME}:${TAG}" \
              ./src/${SERVICE}
            
            echo "scan_strategy=pre-push" >> $GITHUB_OUTPUT
            echo "needs_multiarch=true" >> $GITHUB_OUTPUT
          else
            # Backend: Build ARM64 only
            echo "ðŸ—ï¸ Building $SERVICE for ARM64..."
            
            docker buildx build \
              --platform linux/arm64 \
              --load \
              -t "${IMAGE_NAME}:${TAG}" \
              ./src/${SERVICE}
            
            echo "scan_strategy=pre-push" >> $GITHUB_OUTPUT
            echo "needs_multiarch=false" >> $GITHUB_OUTPUT
          fi
          
          echo "image_name=${IMAGE_NAME}" >> $GITHUB_OUTPUT
          echo "full_image=${IMAGE_NAME}:${TAG}" >> $GITHUB_OUTPUT
          
          echo "âœ… Build completed for scanning"

      - name: Scan Image with Trivy (Before Push)
        id: trivy
        run: |
          SERVICE="${{ matrix.service }}"
          IMAGE="${{ steps.build.outputs.full_image }}"
          
          echo "ðŸ” Scanning $IMAGE before push..."
          
          trivy image \
            --severity HIGH,CRITICAL \
            --format table \
            --exit-code 0 \
            "$IMAGE" 2>&1 | tee /tmp/trivy-report.txt
          
          trivy image \
            --severity HIGH,CRITICAL \
            --format sarif \
            --output trivy-results.sarif \
            "$IMAGE" 2>/dev/null || echo '{"version":"2.1.0","runs":[]}' > trivy-results.sarif
          
          trivy image \
            --severity HIGH,CRITICAL \
            --format json \
            --output trivy-results.json \
            "$IMAGE" 2>/dev/null || echo '{"Results":[]}' > trivy-results.json
          
          CRITICAL=$(jq '[.Results[]?.Vulnerabilities[]? | select(.Severity=="CRITICAL")] | length' trivy-results.json 2>/dev/null || echo "0")
          HIGH=$(jq '[.Results[]?.Vulnerabilities[]? | select(.Severity=="HIGH")] | length' trivy-results.json 2>/dev/null || echo "0")
          TOTAL=$((CRITICAL + HIGH))
          
          echo "critical=$CRITICAL" >> $GITHUB_OUTPUT
          echo "high=$HIGH" >> $GITHUB_OUTPUT
          echo "total=$TOTAL" >> $GITHUB_OUTPUT
          
          cat >> $GITHUB_STEP_SUMMARY << EOF
          ## ðŸ” Trivy Scan (Pre-Push): $SERVICE
          **Image:** \`$IMAGE\`
          
          | ðŸš¨ Critical | âš ï¸ High | ðŸ“Š Total |
          |------------|---------|----------|
          | $CRITICAL | $HIGH | $TOTAL |
          
          <details>
          <summary>ðŸ“‹ View Report</summary>
          
          \`\`\`
          $(cat /tmp/trivy-report.txt)
          \`\`\`
          
          </details>
          EOF
          
          # BLOCK if critical vulnerabilities
          if [[ $CRITICAL -gt 0 ]]; then
            echo "âŒ BLOCKING: $CRITICAL critical vulnerabilities!"
            echo "::error::Critical vulnerabilities in $SERVICE"
            exit 1
          fi
          
          echo "âœ… Scan passed - safe to push"

      - name: Build and Push Multi-Arch Frontend
        if: |
          steps.build.outputs.needs_multiarch == 'true' &&
          github.event_name == 'push' &&
          github.ref == 'refs/heads/main'
        run: |
          SERVICE="${{ matrix.service }}"
          TAG="${{ steps.meta.outputs.tag }}"
          IMAGE_NAME="${{ steps.build.outputs.image_name }}"
          
          echo "ðŸ—ï¸ Building frontend multi-arch (amd64 + arm64)..."
          echo "   âœ… Security scan passed"
          
          # Now build and push multi-arch (uses cache from AMD64 build)
          docker buildx build \
            --platform linux/amd64,linux/arm64 \
            --build-arg VITE_API_URL=/api \
            --push \
            -t "${IMAGE_NAME}:${TAG}" \
            -t "${IMAGE_NAME}:latest" \
            ./src/${SERVICE}
          
          echo "âœ… Multi-arch frontend pushed: ${IMAGE_NAME}:${TAG}"

      - name: Push Backend Images
        if: |
          steps.build.outputs.needs_multiarch == 'false' &&
          github.event_name == 'push' &&
          github.ref == 'refs/heads/main'
        run: |
          IMAGE_NAME="${{ steps.build.outputs.image_name }}"
          TAG="${{ steps.meta.outputs.tag }}"
          
          echo "ðŸš€ Pushing ARM64 backend image..."
          docker push "${IMAGE_NAME}:${TAG}"
          docker tag "${IMAGE_NAME}:${TAG}" "${IMAGE_NAME}:latest"
          docker push "${IMAGE_NAME}:latest"
          
          echo "âœ… Pushed: ${IMAGE_NAME}:${TAG}"

      - name: Upload Trivy Results as Artifact
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: trivy-results-${{ matrix.service }}
          path: |
            trivy-results.sarif
            trivy-results.json
          retention-days: 30

      - name: Image Build Summary
        if: always()
        run: |
          SERVICE="${{ matrix.service }}"
          TAG="${{ steps.meta.outputs.tag }}"
          IMAGE="${{ steps.build.outputs.full_image }}"
          
          cat >> $GITHUB_STEP_SUMMARY << EOF
          ## âœ… Build Summary: $SERVICE
          
          **Image:** \`$IMAGE\`
          **Tag:** \`$TAG\`
          **Architectures:** linux/amd64, linux/arm64
          **Status:** ${{ job.status }}
          **Pushed to:** Docker Hub
          
          EOF

  # ==========================================
  # STAGE 4: Update Manifests
  # ==========================================
  update-manifests:
    name: ðŸ“ Update Helm Values
    runs-on: ubuntu-latest
    needs: [detect-changes, build-and-scan]
    if: |
      always() &&
      github.event_name == 'push' &&
      github.ref == 'refs/heads/main' &&
      needs.build-and-scan.result == 'success'
    
    permissions:
      contents: write
    
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Update Helm Values
        run: |
          # Get the tag from build job
          TAG="v1.0.${{ github.run_number }}"
          
          echo "ðŸ“ Updating Helm values with tag: $TAG"
          
          # Update values.yaml with new image tags
          sed -i "s|tag: .*|tag: $TAG|g" apps/freshbonds/values.yaml
          
          # Show changes
          git diff apps/freshbonds/values.yaml
          
          # Commit and push
          git config user.name "GitHub Actions"
          git config user.email "actions@github.com"
          
          git add apps/freshbonds/values.yaml
          
          if git diff --staged --quiet; then
            echo "â„¹ï¸ No changes to commit"
          else
            git commit -m "chore: update image tags to $TAG [skip ci]"
            git push
            echo "âœ… Updated Helm values and pushed to main"
          fi

      - name: Trigger ArgoCD Sync (Optional)
        run: |
          echo "ðŸ”„ ArgoCD will auto-sync within 3 minutes"
          echo "Or manually sync: kubectl patch app freshbonds -n argocd -p '{\"spec\":{\"syncPolicy\":{\"automated\":{\"prune\":true}}}}' --type merge"

  # ==========================================
  # STAGE 5: Notify
  # ==========================================
  notify:
    name: ðŸ“¢ Notify Pipeline Status
    runs-on: ubuntu-latest
    needs: [detect-changes, policy-checks, build-and-scan, update-manifests]
    if: always()
    
    steps:
      - name: Pipeline Summary
        run: |
          echo "ðŸŽ¯ Pipeline Execution Summary"
          echo "================================"
          echo ""
          echo "ðŸ“Š Stage Results:"
          echo "  - Detect Changes: ${{ needs.detect-changes.result }}"
          echo "  - Policy Checks: ${{ needs.policy-checks.result }}"
          echo "  - Build & Scan: ${{ needs.build-and-scan.result }}"
          echo "  - Update Manifests: ${{ needs.update-manifests.result }}"
          echo ""
          
          # Overall status
          if [[ "${{ needs.build-and-scan.result }}" == "success" ]]; then
            echo "âœ… Pipeline completed successfully!"
            exit 0
          else
            echo "âŒ Pipeline failed or was skipped"
            exit 1
          fi
