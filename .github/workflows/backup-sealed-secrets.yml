name: Ensure SealedSecrets Keys

on:
  workflow_dispatch:
    inputs:
      force_update:
        description: 'Force update GitHub Secret with current cluster keys'
        required: false
        default: false
        type: boolean

permissions:
  contents: write

jobs:
  ensure-keys:
    name: ğŸ”‘ Ensure SealedSecrets Keys Are Installed
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Install kubectl
        run: |
          curl -LO "https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl"
          sudo install -o root -g root -m 0755 kubectl /usr/local/bin/kubectl
          echo "âœ… kubectl installed"

      - name: Configure Kubernetes
        run: |
          mkdir -p $HOME/.kube
          echo "${{ secrets.KUBECONFIG }}" | base64 -d > $HOME/.kube/config
          chmod 600 $HOME/.kube/config
          
          # Test connection
          kubectl cluster-info
          echo "âœ… Connected to cluster"

      - name: Check and Restore SealedSecrets Keys
        id: ensure
        run: |
          echo "ğŸ”‘ Ensuring SealedSecrets keys are installed..."
          
          # Check if keys exist in cluster
          KEY_COUNT=$(kubectl get secrets -n sealed-secrets \
            -l sealedsecrets.bitnami.com/sealed-secrets-key=active \
            --no-headers 2>/dev/null | wc -l || echo "0")
          
          if [[ "$KEY_COUNT" -eq 0 ]] || [[ "${{ github.event.inputs.force_update }}" == "true" ]]; then
            echo "âš ï¸ No keys found in cluster or force update requested"
            echo "ğŸ“¥ Restoring keys from GitHub Secret..."
            
            # Restore from GitHub Secret
            echo "${{ secrets.SEALED_SECRETS_PRIVATE_KEY }}" | base64 -d > /tmp/sealed-secrets-restore.yaml
            
            # Verify it's valid
            if ! grep -q "kind: Secret" /tmp/sealed-secrets-restore.yaml; then
              echo "âŒ SEALED_SECRETS_PRIVATE_KEY is not valid"
              exit 1
            fi
            
            # Apply the keys
            kubectl apply -f /tmp/sealed-secrets-restore.yaml
            
            # Restart controller
            kubectl rollout restart deployment/sealed-secrets-controller -n sealed-secrets || \
            kubectl rollout restart deployment/sealed-secrets -n sealed-secrets || true
            
            echo "âœ… Keys restored from GitHub Secret"
            echo "action=restored" >> $GITHUB_OUTPUT
          else
            echo "âœ… Keys already exist in cluster ($KEY_COUNT active keys)"
            echo "action=exists" >> $GITHUB_OUTPUT
          fi
          
          # Get current keys for verification
          kubectl get secrets -n sealed-secrets \
            -l sealedsecrets.bitnami.com/sealed-secrets-key=active \
            -o yaml > sealed-secrets-keys-backup.yaml
          
          # Also save to timestamped backup
          TIMESTAMP=$(date +%Y%m%d-%H%M%S)
          mkdir -p backups/sealed-secrets
          cp sealed-secrets-keys-backup.yaml "backups/sealed-secrets/backup-$TIMESTAMP.yaml"
          
          # Extract and save public key separately for easy access
          kubectl get secret -n sealed-secrets \
            -l sealedsecrets.bitnami.com/sealed-secrets-key=active \
            -o jsonpath='{.items[0].data.tls\.crt}' | base64 -d > sealed-secrets-public-key.crt
          
          # Create base64 encoded version for GitHub Secret
          cat sealed-secrets-keys-backup.yaml | base64 -w 0 > sealed-secrets-keys-backup.b64
          
          echo "âœ… Current keys saved to:"
          echo "  - sealed-secrets-keys-backup.yaml (reference only)"
          echo "  - backups/sealed-secrets/backup-$TIMESTAMP.yaml (timestamped)"
          echo "  - sealed-secrets-public-key.crt (for creating new SealedSecrets)"
          echo ""
          echo "timestamp=$TIMESTAMP" >> $GITHUB_OUTPUT
          
          # Get fingerprint for verification
          FINGERPRINT=$(kubectl get secret -n sealed-secrets \
            -l sealedsecrets.bitnami.com/sealed-secrets-key=active \
            -o jsonpath='{.items[0].metadata.name}')
          echo "fingerprint=$FINGERPRINT" >> $GITHUB_OUTPUT
          
          # Count keys
          KEY_COUNT=$(kubectl get secrets -n sealed-secrets \
            -l sealedsecrets.bitnami.com/sealed-secrets-key=active \
            --no-headers | wc -l)
          echo "key_count=$KEY_COUNT" >> $GITHUB_OUTPUT

      - name: Configure Git
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

      - name: Commit Backup to Repository
        run: |
          git add sealed-secrets-keys-backup.yaml
          git add sealed-secrets-public-key.crt
          git add backups/sealed-secrets/
          
          if git diff --staged --quiet; then
            echo "â„¹ï¸ No changes to commit (keys unchanged)"
            exit 0
          fi
          
          git commit -m "chore: update SealedSecrets keys reference [skip ci]

          Timestamp: ${{ steps.ensure.outputs.timestamp }}
          Action: ${{ steps.ensure.outputs.action }}
          Key fingerprint: ${{ steps.ensure.outputs.fingerprint }}
          Active keys: ${{ steps.ensure.outputs.key_count }}
          
          â„¹ï¸ Master key stored in GitHub Secret: SEALED_SECRETS_PRIVATE_KEY"
          
          git push origin main
          
          echo "âœ… Backup committed to repository"

      - name: Verify Backup Integrity
        run: |
          echo "ğŸ” Verifying backup integrity..."
          
          # Check if backup file is valid YAML
          if ! grep -q "kind: Secret" sealed-secrets-keys-backup.yaml; then
            echo "âŒ Backup file is not a valid Kubernetes Secret"
            exit 1
          fi
          
          # Check if private key exists
          if ! grep -q "tls.key:" sealed-secrets-keys-backup.yaml; then
            echo "âŒ Private key missing from backup"
            exit 1
          fi
          
          # Check if public cert exists
          if ! grep -q "tls.crt:" sealed-secrets-keys-backup.yaml; then
            echo "âŒ Public certificate missing from backup"
            exit 1
          fi
          
          echo "âœ… Backup integrity verified"

      - name: Create Report
        if: always()
        run: |
          STATUS="${{ job.status }}"
          ACTION="${{ steps.ensure.outputs.action }}"
          
          if [[ "$STATUS" == "success" ]]; then
            EMOJI="âœ…"
            if [[ "$ACTION" == "restored" ]]; then
              MESSAGE="SealedSecrets keys restored from GitHub Secret"
            else
              MESSAGE="SealedSecrets keys verified in cluster"
            fi
          else
            EMOJI="âŒ"
            MESSAGE="SealedSecrets key check failed"
          fi
          
          cat >> $GITHUB_STEP_SUMMARY <<EOF
          # $EMOJI SealedSecrets Key Management
          
          **Status:** $MESSAGE  
          **Action:** $ACTION
          **Timestamp:** ${{ steps.ensure.outputs.timestamp }}  
          **Key Fingerprint:** \`${{ steps.ensure.outputs.fingerprint }}\`  
          **Active Keys:** ${{ steps.ensure.outputs.key_count }}
          
          ## Key Storage
          1. **Primary Source (Permanent):**
             - GitHub Secret: \`SEALED_SECRETS_PRIVATE_KEY\`
             - This is your master key - never changes
          
          2. **Reference Files (Git):**
             - \`sealed-secrets-keys-backup.yaml\` (reference only)
             - \`sealed-secrets-public-key.crt\` (for creating new SealedSecrets)
             - \`backups/sealed-secrets/backup-${{ steps.ensure.outputs.timestamp }}.yaml\`
          
          ## Automatic Key Restoration
          
          Keys are automatically restored from \`SEALED_SECRETS_PRIVATE_KEY\` when:
          - Cluster restarts and loses keys
          - New cluster is provisioned
          - This workflow detects missing keys
          
          **No manual intervention needed!**
          
          ## Important Notes
          - âœ… **GitHub Secret is source of truth** - \`SEALED_SECRETS_PRIVATE_KEY\`
          - âœ… **Automatic restoration** - keys restored on cluster restart
          - âš ï¸ **Never change GitHub Secret** - breaking change for all SealedSecrets
          - âš ï¸ **Keep repository PRIVATE** - reference files contain keys
          
          ## Using the Public Key
          
          To create new SealedSecrets, use \`sealed-secrets-public-key.crt\`:
          
          \`\`\`bash
          # Seal a secret
          kubectl create secret generic mysecret --from-literal=password=test123 --dry-run=client -o yaml | \\
            kubeseal --cert=sealed-secrets-public-key.crt -o yaml > mysealedsecret.yaml
          \`\`\`
          
          ---
          *Automated SealedSecrets backup workflow*
          EOF

      - name: Summary
        run: |
          ACTION="${{ steps.ensure.outputs.action }}"
          
          echo ""
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          if [[ "$ACTION" == "restored" ]]; then
            echo "âœ… Keys Restored from SEALED_SECRETS_PRIVATE_KEY"
            echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
            echo ""
            echo "Your cluster now has the permanent SealedSecrets keys."
            echo "All existing SealedSecrets will be automatically decrypted."
          else
            echo "âœ… Keys Already Present in Cluster"
            echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
            echo ""
            echo "No action needed. Keys are correctly installed."
          fi
          echo ""
          echo "Public key saved to: sealed-secrets-public-key.crt"
          echo "Use this to create new SealedSecrets."
          echo ""
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
