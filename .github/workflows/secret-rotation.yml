name: Automated Secret Rotation

on:
  schedule:
    # Production secrets: Every 14 days (1st and 15th) at 3 AM UTC
    - cron: '0 3 1,15 * *'
    # JWT tokens: Weekly rotation on Wednesdays at 2 AM UTC  
    - cron: '0 2 * * 3'
  workflow_dispatch:
    inputs:
      secret_type:
        description: 'Type of secret to rotate'
        required: true
        default: 'all'
        type: choice
        options:
          - all
          - jwt
          - database
          - api-keys
          - tls-certs
      force_rotation:
        description: 'Force rotation even if recently rotated'
        required: false
        default: false
        type: boolean
      notification:
        description: 'Send rotation notification'
        required: false
        default: true
        type: boolean

# Prevent concurrent secret rotations
concurrency:
  group: secret-rotation-dev
  cancel-in-progress: false

permissions:
  contents: write
  issues: write  # For creating audit issues

env:
  KUBESEAL_VERSION: '0.24.0'

jobs:
  rotate-secrets:
    name: ðŸ”„ Rotate Secrets
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          fetch-depth: 0

      - name: Install Dependencies
        run: |
          # Install kubeseal for SealedSecrets
          wget https://github.com/bitnami-labs/sealed-secrets/releases/download/v${KUBESEAL_VERSION}/kubeseal-${KUBESEAL_VERSION}-linux-amd64.tar.gz
          tar -xvzf kubeseal-${KUBESEAL_VERSION}-linux-amd64.tar.gz
          sudo mv kubeseal /usr/local/bin/
          chmod +x /usr/local/bin/kubeseal
          
          # Install kubectl
          curl -LO "https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl"
          sudo install -o root -g root -m 0755 kubectl /usr/local/bin/kubectl
          
          echo "âœ… Tools installed"

      - name: Configure Kubernetes
        run: |
          mkdir -p $HOME/.kube
          echo "${{ secrets.KUBECONFIG }}" | base64 -d > $HOME/.kube/config
          chmod 600 $HOME/.kube/config
          
          # Test connection
          kubectl cluster-info || echo "âš ï¸ Could not connect to cluster (will continue with sealed secrets generation)"

      - name: Setup SealedSecrets Public Key
        run: |
          echo "ðŸ”‘ Setting up SealedSecrets public key..."
          
          # Try to get from cluster first
          if kubectl get ns sealed-secrets &>/dev/null; then
            echo "ðŸ“¥ Fetching public key from cluster..."
            kubectl get secret -n sealed-secrets \
              -l sealedsecrets.bitnami.com/sealed-secrets-key=active \
              -o jsonpath='{.items[0].data.tls\.crt}' | base64 -d > sealed-secrets-public-key.crt
            echo "âœ… Public key fetched from cluster"
          else
            echo "âš ï¸ Cluster not accessible, extracting from GitHub Secret..."
            
            # Extract public key from SEALED_SECRETS_PRIVATE_KEY
            if [[ -n "${{ secrets.SEALED_SECRETS_PRIVATE_KEY }}" ]]; then
              echo "${{ secrets.SEALED_SECRETS_PRIVATE_KEY }}" | base64 -d > /tmp/sealed-secrets-full.yaml
              
              # Extract just the public certificate
              cat /tmp/sealed-secrets-full.yaml | \
                grep "tls.crt:" | \
                awk '{print $2}' | \
                base64 -d > sealed-secrets-public-key.crt
              
              rm -f /tmp/sealed-secrets-full.yaml
              echo "âœ… Public key extracted from GitHub Secret"
            else
              # Fallback: use file from repo if it exists
              if [[ -f "sealed-secrets-public-key.crt" ]]; then
                echo "âœ… Using public key from repository"
              else
                echo "âŒ No public key available!"
                echo "   Please ensure one of:"
                echo "   1. SEALED_SECRETS_PRIVATE_KEY is set in GitHub Secrets"
                echo "   2. sealed-secrets-public-key.crt exists in repository"
                echo "   3. Cluster is accessible"
                exit 1
              fi
            fi
          fi
          
          # Verify the public key is valid
          if openssl x509 -in sealed-secrets-public-key.crt -noout -text &>/dev/null; then
            echo "âœ… Public key is valid"
          else
            echo "âŒ Public key is invalid"
            exit 1
          fi

      - name: Rotate MongoDB User Password
        id: rotate_mongodb
        if: |
          github.event.inputs.secret_type == 'all' || 
          github.event.inputs.secret_type == 'database'
        run: |
          echo "ðŸ” Rotating MongoDB password..."
          
          # Load MongoDB connection details from GitHub Secrets (static configuration)
          DB_HOST="${{ secrets.MONGO_HOST }}"
          DB_NAME="${{ secrets.MONGO_DATABASE }}"
          DB_USER="${{ secrets.MONGO_USERNAME }}"
          
          echo "ðŸ“Š MongoDB Details:"
          echo "  Host: $DB_HOST"
          echo "  Database: $DB_NAME"
          echo "  User: $DB_USER"
          
          # Generate new secure password (always rotates)
          NEW_DB_PASSWORD=$(openssl rand -base64 32 | tr -d "=+/" | cut -c1-32)
          
          # Update password on MongoDB Atlas using API
          if [[ -n "${{ secrets.MONGO_API_KEY }}" ]]; then
            echo "ðŸ”„ Updating password via MongoDB Atlas API..."
            
            # MongoDB Atlas API uses PUBLIC_KEY:PRIVATE_KEY for authentication
            # Format of MONGO_API_KEY should be: "PUBLIC_KEY:PRIVATE_KEY"
            # Get the Atlas Project/Group ID from MONGO_PROJECT_ID secret
            ATLAS_PROJECT_ID="${{ secrets.MONGO_PROJECT_ID }}"
            ATLAS_PUBLIC_KEY=$(echo "${{ secrets.MONGO_API_KEY }}" | cut -d':' -f1)
            ATLAS_PRIVATE_KEY=$(echo "${{ secrets.MONGO_API_KEY }}" | cut -d':' -f2)
            
            echo "ðŸ“ Project ID: ${ATLAS_PROJECT_ID:0:8}..."
            echo "ðŸ”‘ Public Key: ${ATLAS_PUBLIC_KEY:0:8}..."
            
            # Update the database user password
            RESPONSE=$(curl -s -w "\n%{http_code}" -X PATCH \
              "https://cloud.mongodb.com/api/atlas/v1.0/groups/${ATLAS_PROJECT_ID}/databaseUsers/admin/${DB_USER}" \
              -u "${ATLAS_PUBLIC_KEY}:${ATLAS_PRIVATE_KEY}" \
              --digest \
              -H "Content-Type: application/json" \
              -d "{\"password\": \"${NEW_DB_PASSWORD}\"}")
            
            HTTP_CODE=$(echo "$RESPONSE" | tail -n1)
            
            if [[ "$HTTP_CODE" =~ ^2 ]]; then
              echo "âœ… MongoDB password updated on Atlas (HTTP $HTTP_CODE)"
              echo "db_password_rotated=true" >> $GITHUB_OUTPUT
            else
              echo "âŒ MongoDB API call failed (HTTP $HTTP_CODE)"
              echo "$RESPONSE" | head -n-1
              echo "db_password_rotated=false" >> $GITHUB_OUTPUT
              exit 1
            fi
          else
            echo "âŒ MONGO_API_KEY not configured - cannot rotate MongoDB password"
            echo "   Add MongoDB Atlas API key to GitHub Secrets as MONGO_API_KEY"
            echo "db_password_rotated=false" >> $GITHUB_OUTPUT
            exit 1
          fi
          
          # Build new MongoDB URI with rotated password
          NEW_MONGODB_URI="mongodb+srv://${DB_USER}:${NEW_DB_PASSWORD}@${DB_HOST}/${DB_NAME}?appName=Dev"
          echo "mongodb_uri=$NEW_MONGODB_URI" >> $GITHUB_OUTPUT

      - name: Rotate PagerDuty Integration Keys
        id: rotate_pagerduty
        if: |
          github.event.inputs.secret_type == 'all' || 
          github.event.inputs.secret_type == 'api-keys'
        run: |
          echo "ðŸ” Rotating PagerDuty integration keys..."
          
          if [[ -n "${{ secrets.PAGERDUTY_API_KEY }}" ]]; then
            # Rotate FreshBonds Application integration key
            SERVICE_ID_APP="${{ secrets.PAGERDUTY_SERVICE_ID_APP }}"
            
            echo "ðŸ”„ Creating new integration for FreshBonds Application (${SERVICE_ID_APP})..."
            
            RESPONSE_APP=$(curl -s -X POST \
              "https://api.pagerduty.com/services/${SERVICE_ID_APP}/integrations" \
              -H "Authorization: Token token=${{ secrets.PAGERDUTY_API_KEY }}" \
              -H "Content-Type: application/json" \
              -H "Accept: application/vnd.pagerduty+json;version=2" \
              -d '{
                "integration": {
                  "type": "events_api_v2_inbound_integration",
                  "name": "FreshBonds App - Auto Rotated"
                }
              }')
            
            NEW_PD_KEY_APP=$(echo "$RESPONSE_APP" | grep -o '"integration_key":"[^"]*' | cut -d'"' -f4)
            
            if [[ -n "$NEW_PD_KEY_APP" ]]; then
              echo "âœ… FreshBonds App integration key created"
              echo "pagerduty_key_app=$NEW_PD_KEY_APP" >> $GITHUB_OUTPUT
            else
              echo "âŒ Failed to create FreshBonds App integration"
              echo "$RESPONSE_APP"
              exit 1
            fi
            
            # Rotate Kubernetes Infrastructure integration key
            SERVICE_ID_INFRA="${{ secrets.PAGERDUTY_SERVICE_ID_INFRA }}"
            
            echo "ðŸ”„ Creating new integration for Kubernetes Infrastructure (${SERVICE_ID_INFRA})..."
            
            RESPONSE_INFRA=$(curl -s -X POST \
              "https://api.pagerduty.com/services/${SERVICE_ID_INFRA}/integrations" \
              -H "Authorization: Token token=${{ secrets.PAGERDUTY_API_KEY }}" \
              -H "Content-Type: application/json" \
              -H "Accept: application/vnd.pagerduty+json;version=2" \
              -d '{
                "integration": {
                  "type": "events_api_v2_inbound_integration",
                  "name": "K8s Alertmanager - Auto Rotated"
                }
              }')
            
            NEW_PD_KEY_INFRA=$(echo "$RESPONSE_INFRA" | grep -o '"integration_key":"[^"]*' | cut -d'"' -f4)
            
            if [[ -n "$NEW_PD_KEY_INFRA" ]]; then
              echo "âœ… K8s Infrastructure integration key created"
              echo "pagerduty_key_infra=$NEW_PD_KEY_INFRA" >> $GITHUB_OUTPUT
              echo "pagerduty_rotated=true" >> $GITHUB_OUTPUT
            else
              echo "âŒ Failed to create K8s Infrastructure integration"
              echo "$RESPONSE_INFRA"
              exit 1
            fi
          else
            echo "âŒ PAGERDUTY_API_KEY not configured - cannot rotate"
            exit 1
          fi

      - name: Generate Internal Secrets
        id: generate
        run: |
          NAMESPACE="${{ github.event.inputs.namespace || 'dev' }}"
          SECRET_TYPE="${{ github.event.inputs.secret_type || 'all' }}"
          
          echo "ðŸ” Generating internal secrets for namespace: $NAMESPACE"
          echo "ðŸ“ Secret type: $SECRET_TYPE"
          
          # Function to generate secure random string
          generate_secret() {
            openssl rand -base64 32 | tr -d "=+/" | cut -c1-32
          }
          
          # Generate internal secrets that don't require external API calls
          if [[ "$SECRET_TYPE" == "all" ]] || [[ "$SECRET_TYPE" == "jwt" ]]; then
            JWT_SECRET=$(generate_secret)
            echo "jwt_secret=$JWT_SECRET" >> $GITHUB_OUTPUT
            echo "âœ… Generated JWT secret"
          fi
          
          if [[ "$SECRET_TYPE" == "all" ]] || [[ "$SECRET_TYPE" == "api-keys" ]]; then
            CALLBACK_TOKEN=$(generate_secret)
            echo "callback_token=$CALLBACK_TOKEN" >> $GITHUB_OUTPUT
            echo "âœ… Generated callback token"
          fi
          
          echo "rotation_timestamp=$(date -u +'%Y-%m-%dT%H:%M:%SZ')" >> $GITHUB_OUTPUT

      - name: Backup Current Secrets
        run: |
          NAMESPACE="dev"
          TIMESTAMP=$(date +%Y%m%d-%H%M%S)
          
          echo "ðŸ’¾ Creating backup reference..."
          echo "Backup timestamp: $TIMESTAMP" > /tmp/backup-info.txt
          echo "Note: SealedSecret will be updated in apps/freshbonds/templates/"
          echo "âœ… Backup info created"

      - name: Create SealedSecret for FreshBonds
        if: steps.generate.outputs.jwt_secret != ''
        run: |
          NAMESPACE="${{ github.event.inputs.namespace || 'dev' }}"
          JWT_SECRET="${{ steps.generate.outputs.jwt_secret }}"
          MONGODB_URI="${{ steps.rotate_mongodb.outputs.mongodb_uri }}"
          PAGERDUTY_KEY_APP="${{ steps.rotate_pagerduty.outputs.pagerduty_key_app }}"
          CALLBACK_TOKEN="${{ steps.generate.outputs.callback_token }}"
          
          echo "ðŸ“ Creating sealed secret for freshbonds..."
          
          # Create temporary secret manifest
          cat > /tmp/freshbonds-secret.yaml <<'SECRETEOF'
          apiVersion: v1
          kind: Secret
          metadata:
            name: freshbonds-secret
            namespace: NAMESPACE_PLACEHOLDER
            annotations:
              rotated-at: "TIMESTAMP_PLACEHOLDER"
              rotated-by: "github-actions"
              mongodb-rotated: "MONGODB_ROTATED_PLACEHOLDER"
              pagerduty-rotated: "PAGERDUTY_ROTATED_PLACEHOLDER"
          type: Opaque
          stringData:
            JWT_SECRET: "JWT_SECRET_PLACEHOLDER"
            MONGODB_URI: "MONGODB_URI_PLACEHOLDER"
            PAGERDUTY_INTEGRATION_KEY: "PAGERDUTY_KEY_PLACEHOLDER"
            IPG_CALLBACK_TOKEN: "CALLBACK_TOKEN_PLACEHOLDER"
            IPG_APP_NAME: "IPG_APP_NAME_PLACEHOLDER"
            IPG_APP_ID: "IPG_APP_ID_PLACEHOLDER"
            IPG_APP_TOKEN: "IPG_APP_TOKEN_PLACEHOLDER"
            IPG_HASH_SALT: "IPG_HASH_SALT_PLACEHOLDER"
            IPG_CALLBACK_URL: "IPG_CALLBACK_URL_PLACEHOLDER"
            NODE_ENV: "production"
          SECRETEOF
          
          # Replace placeholders
          sed -i "s|NAMESPACE_PLACEHOLDER|$NAMESPACE|g" /tmp/freshbonds-secret.yaml
          sed -i "s|TIMESTAMP_PLACEHOLDER|${{ steps.generate.outputs.rotation_timestamp }}|g" /tmp/freshbonds-secret.yaml
          sed -i "s|MONGODB_ROTATED_PLACEHOLDER|${{ steps.rotate_mongodb.outputs.db_password_rotated }}|g" /tmp/freshbonds-secret.yaml
          sed -i "s|PAGERDUTY_ROTATED_PLACEHOLDER|${{ steps.rotate_pagerduty.outputs.pagerduty_rotated }}|g" /tmp/freshbonds-secret.yaml
          sed -i "s|JWT_SECRET_PLACEHOLDER|$JWT_SECRET|g" /tmp/freshbonds-secret.yaml
          sed -i "s|MONGODB_URI_PLACEHOLDER|$MONGODB_URI|g" /tmp/freshbonds-secret.yaml
          sed -i "s|PAGERDUTY_KEY_PLACEHOLDER|$PAGERDUTY_KEY_APP|g" /tmp/freshbonds-secret.yaml
          sed -i "s|CALLBACK_TOKEN_PLACEHOLDER|$CALLBACK_TOKEN|g" /tmp/freshbonds-secret.yaml
          sed -i "s|IPG_APP_NAME_PLACEHOLDER|${{ secrets.IPG_APP_NAME }}|g" /tmp/freshbonds-secret.yaml
          sed -i "s|IPG_APP_ID_PLACEHOLDER|${{ secrets.IPG_APP_ID }}|g" /tmp/freshbonds-secret.yaml
          sed -i "s|IPG_APP_TOKEN_PLACEHOLDER|${{ secrets.IPG_APP_TOKEN }}|g" /tmp/freshbonds-secret.yaml
          sed -i "s|IPG_HASH_SALT_PLACEHOLDER|${{ secrets.IPG_HASH_SALT }}|g" /tmp/freshbonds-secret.yaml
          sed -i "s|IPG_CALLBACK_URL_PLACEHOLDER|${{ secrets.IPG_CALLBACK_URL }}|g" /tmp/freshbonds-secret.yaml
          
          # Seal the secret using public key from previous step
          echo "ðŸ”’ Sealing FreshBonds secret..."
          kubeseal --format=yaml --cert=sealed-secrets-public-key.crt \
            < /tmp/freshbonds-secret.yaml \
            > apps/freshbonds/templates/sealed-secret.yaml
          
          echo "âœ… Created sealed secret: apps/freshbonds/templates/sealed-secret.yaml"
          rm -f /tmp/freshbonds-secret.yaml

      - name: Create SealedSecret for Alertmanager PagerDuty
        if: steps.rotate_pagerduty.outputs.pagerduty_rotated == 'true'
        run: |
          PAGERDUTY_KEY_INFRA="${{ steps.rotate_pagerduty.outputs.pagerduty_key_infra }}"
          
          echo "ðŸ“ Creating sealed secret for Alertmanager PagerDuty..."
          
          # Create temporary secret manifest
          cat > /tmp/alertmanager-pagerduty-secret.yaml <<'ALERTEOF'
          apiVersion: v1
          kind: Secret
          metadata:
            name: alertmanager-pagerduty-key
            namespace: monitoring
            annotations:
              rotated-at: "TIMESTAMP_PLACEHOLDER"
              rotated-by: "github-actions"
          type: Opaque
          stringData:
            integration-key: "PAGERDUTY_KEY_PLACEHOLDER"
          ALERTEOF
          
          # Replace placeholders
          sed -i "s|TIMESTAMP_PLACEHOLDER|${{ steps.generate.outputs.rotation_timestamp }}|g" /tmp/alertmanager-pagerduty-secret.yaml
          sed -i "s|PAGERDUTY_KEY_PLACEHOLDER|$PAGERDUTY_KEY_INFRA|g" /tmp/alertmanager-pagerduty-secret.yaml
          
          # Seal the secret
          echo "ðŸ”’ Sealing Alertmanager PagerDuty secret..."
          kubeseal --format=yaml --cert=sealed-secrets-public-key.crt \
            < /tmp/alertmanager-pagerduty-secret.yaml \
            > clusters/test-cluster/05-infrastructure/alertmanager-pagerduty-sealedsecret.yaml
          
          echo "âœ… Created sealed secret: clusters/test-cluster/05-infrastructure/alertmanager-pagerduty-sealedsecret.yaml"
          rm -f /tmp/alertmanager-pagerduty-secret.yaml

      - name: Update Secret Rotation Log
        run: |
          NAMESPACE="dev"
          SECRET_TYPE="${{ github.event.inputs.secret_type || 'all' }}"
          TIMESTAMP="${{ steps.generate.outputs.rotation_timestamp }}"
          MONGODB_ROTATED="${{ steps.rotate_mongodb.outputs.db_password_rotated }}"
          PAGERDUTY_ROTATED="${{ steps.rotate_pagerduty.outputs.pagerduty_rotated }}"
          
          mkdir -p docs/rotation-logs
          
          cat >> docs/rotation-logs/rotation-history.md <<EOF
          
          ## Rotation: $TIMESTAMP
          - **Namespace:** $NAMESPACE
          - **Secret Type:** $SECRET_TYPE
          - **Triggered By:** ${{ github.actor }}
          - **MongoDB Rotated:** $MONGODB_ROTATED
          - **PagerDuty Rotated:** $PAGERDUTY_ROTATED
          - **Workflow Run:** ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}
          - **Commit:** ${{ github.sha }}
          
          EOF
          
          echo "âœ… Updated rotation log"

      - name: Configure Git
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

      - name: Commit and Push Changes
        run: |
          NAMESPACE="dev"
          TIMESTAMP="${{ steps.generate.outputs.rotation_timestamp }}"
          
          # Only add files that should be committed (not secrets/ directory)
          git add apps/freshbonds/templates/sealed-secret.yaml
          git add clusters/test-cluster/05-infrastructure/alertmanager-pagerduty-sealedsecret.yaml
          git add docs/rotation-logs/rotation-history.md
          
          if git diff --staged --quiet; then
            echo "â„¹ï¸ No changes to commit"
            exit 0
          fi
          
          git commit -m "chore: rotate secrets for $NAMESPACE [skip ci]

          Rotation timestamp: $TIMESTAMP
          Triggered by: ${{ github.actor }}
          
          âœ… SealedSecret updated
          ðŸ”„ ArgoCD will sync new secrets automatically"
          
          git push origin main
          
          echo "âœ… Secrets rotated and pushed to repository"

      - name: Trigger Application Restart
        run: |
          if [[ -n "${{ secrets.KUBECONFIG }}" ]]; then
            NAMESPACE="dev"
            
            echo "ðŸ”„ Triggering rolling restart of applications..."
            
            # Restart deployments to pick up new secrets
            kubectl rollout restart deployment/freshbonds -n $NAMESPACE || echo "âš ï¸ Could not restart freshbonds"
            kubectl rollout restart deployment/api-gateway -n $NAMESPACE || echo "âš ï¸ Could not restart api-gateway"
            kubectl rollout restart deployment/user-service -n $NAMESPACE || echo "âš ï¸ Could not restart user-service"
            kubectl rollout restart deployment/product-service -n $NAMESPACE || echo "âš ï¸ Could not restart product-service"
            
            echo "âœ… Applications will restart with new secrets"
          else
            echo "âš ï¸ KUBECONFIG not configured, skipping application restart"
          fi

      - name: Verify Deployment Health
        run: |
          if [[ -n "${{ secrets.KUBECONFIG }}" ]]; then
            NAMESPACE="dev"
            
            echo "ðŸ¥ Waiting for deployments to be ready..."
            
            # Wait for deployments (with timeout)
            kubectl rollout status deployment/freshbonds -n $NAMESPACE --timeout=5m || echo "âš ï¸ freshbonds rollout timed out"
            kubectl rollout status deployment/api-gateway -n $NAMESPACE --timeout=5m || echo "âš ï¸ api-gateway rollout timed out"
            kubectl rollout status deployment/user-service -n $NAMESPACE --timeout=5m || echo "âš ï¸ user-service rollout timed out"
            kubectl rollout status deployment/product-service -n $NAMESPACE --timeout=5m || echo "âš ï¸ product-service rollout timed out"
            
            echo ""
            echo "ðŸ“Š Deployment Status:"
            kubectl get deployments -n $NAMESPACE
          else
            echo "âš ï¸ KUBECONFIG not configured, skipping deployment verification"
          fi

      - name: Send Notification
        if: always()
        run: |
          NAMESPACE="dev"
          STATUS="${{ job.status }}"
          MONGODB_ROTATED="${{ steps.rotate_mongodb.outputs.db_password_rotated }}"
          PAGERDUTY_ROTATED="${{ steps.rotate_pagerduty.outputs.pagerduty_rotated }}"
          
          if [[ "$STATUS" == "success" ]]; then
            EMOJI="âœ…"
            MESSAGE="Secret rotation completed successfully"
          else
            EMOJI="âŒ"
            MESSAGE="Secret rotation failed"
          fi
          
          cat >> $GITHUB_STEP_SUMMARY <<EOF
          # $EMOJI Secret Rotation Summary
          
          **Namespace:** $NAMESPACE
          **Status:** $MESSAGE
          **Timestamp:** ${{ steps.generate.outputs.rotation_timestamp }}
          **Triggered By:** ${{ github.actor }}
          
          ## Rotation Status
          - **JWT Secret:** âœ… Rotated (internal)
          - **Callback Token:** âœ… Rotated (internal)
          - **MongoDB Password:** $([ "$MONGODB_ROTATED" == "true" ] && echo "âœ… Rotated on Atlas" || echo "â­ï¸ Skipped (API key not configured)")
          - **PagerDuty Key:** $([ "$PAGERDUTY_ROTATED" == "true" ] && echo "âœ… Rotated on PagerDuty" || echo "â­ï¸ Skipped (API key not configured)")
          
          ## Next Steps
          - ArgoCD will automatically sync the new sealed secrets
          - Monitor application health after rotation
          - Previous secrets backed up in secrets/backups/
          - Verify external service connectivity (MongoDB, PagerDuty)
          
          ## Setup Instructions
          To enable full rotation, add these GitHub Secrets:
          - \`MONGO_API_KEY\` - MongoDB Atlas API key (format: GROUP_ID:PUBLIC_KEY:PRIVATE_KEY)
          - \`PAGERDUTY_API_KEY\` - PagerDuty API token
          - \`PAGERDUTY_SERVICE_ID\` - PagerDuty service ID
          
          ---
          *Automated secret rotation workflow*
          EOF

      - name: Send PagerDuty Alert on Failure
        if: failure()
        run: |
          if [[ -n "${{ secrets.PAGERDUTY_INTEGRATION_KEY }}" ]]; then
            curl -X POST https://events.pagerduty.com/v2/enqueue \
              -H 'Content-Type: application/json' \
              -d '{
                "routing_key": "${{ secrets.PAGERDUTY_INTEGRATION_KEY }}",
                "event_action": "trigger",
                "payload": {
                  "summary": "Secret Rotation Failed - dev",
                  "severity": "error",
                  "source": "GitHub Actions",
                "custom_details": {
                  "namespace": "dev",
                  "secret_type": "${{ github.event.inputs.secret_type || 'all' }}",
                  "workflow_url": "${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}"
                }
              }
            }'
          fi
