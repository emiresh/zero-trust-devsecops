name: Automated Secret Rotation

on:
  schedule:
    # Production secrets: Every 14 days (1st and 15th) at 3 AM UTC
    - cron: '0 3 1,15 * *'
    # JWT tokens: Weekly rotation on Wednesdays at 2 AM UTC  
    - cron: '0 2 * * 3'
  workflow_dispatch:
    inputs:
      namespace:
        description: 'Target namespace'
        required: true
        default: 'production'
        type: choice
        options:
          - production
          - dev
      secret_type:
        description: 'Type of secret to rotate'
        required: true
        default: 'all'
        type: choice
        options:
          - all
          - jwt
          - database
          - api-keys
          - tls-certs
      force_rotation:
        description: 'Force rotation even if recently rotated'
        required: false
        default: false
        type: boolean
      notification:
        description: 'Send rotation notification'
        required: false
        default: true
        type: boolean

# Prevent concurrent secret rotations
concurrency:
  group: secret-rotation-${{ github.event.inputs.namespace || 'production' }}
  cancel-in-progress: false

permissions:
  contents: write
  issues: write  # For creating audit issues

env:
  KUBESEAL_VERSION: '0.24.0'

jobs:
  rotate-secrets:
    name: üîÑ Rotate Secrets
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          fetch-depth: 0

      - name: Install Dependencies
        run: |
          # Install kubeseal for SealedSecrets
          wget https://github.com/bitnami-labs/sealed-secrets/releases/download/v${KUBESEAL_VERSION}/kubeseal-${KUBESEAL_VERSION}-linux-amd64.tar.gz
          tar -xvzf kubeseal-${KUBESEAL_VERSION}-linux-amd64.tar.gz
          sudo mv kubeseal /usr/local/bin/
          chmod +x /usr/local/bin/kubeseal
          
          # Install kubectl
          curl -LO "https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl"
          sudo install -o root -g root -m 0755 kubectl /usr/local/bin/kubectl
          
          echo "‚úÖ Tools installed"

      - name: Configure Kubernetes
        run: |
          mkdir -p $HOME/.kube
          echo "${{ secrets.KUBECONFIG }}" | base64 -d > $HOME/.kube/config
          chmod 600 $HOME/.kube/config
          
          # Test connection
          kubectl cluster-info || echo "‚ö†Ô∏è Could not connect to cluster (will continue with sealed secrets generation)"

      - name: Generate New Secrets
        id: generate
        run: |
          NAMESPACE="${{ github.event.inputs.namespace || 'dev' }}"
          SECRET_TYPE="${{ github.event.inputs.secret_type || 'all' }}"
          
          echo "üîê Generating new secrets for namespace: $NAMESPACE"
          echo "üìù Secret type: $SECRET_TYPE"
          
          # Function to generate secure random string
          generate_secret() {
            openssl rand -base64 32 | tr -d "=+/" | cut -c1-32
          }
          
          # Generate secrets based on type
          if [[ "$SECRET_TYPE" == "all" ]] || [[ "$SECRET_TYPE" == "jwt" ]]; then
            JWT_SECRET=$(generate_secret)
            echo "jwt_secret=$JWT_SECRET" >> $GITHUB_OUTPUT
            echo "‚úÖ Generated JWT secret"
          fi
          
          if [[ "$SECRET_TYPE" == "all" ]] || [[ "$SECRET_TYPE" == "database" ]]; then
            DB_PASSWORD=$(generate_secret)
            echo "db_password=$DB_PASSWORD" >> $GITHUB_OUTPUT
            echo "‚úÖ Generated database password"
          fi
          
          if [[ "$SECRET_TYPE" == "all" ]] || [[ "$SECRET_TYPE" == "api-keys" ]]; then
            API_KEY=$(generate_secret)
            CALLBACK_TOKEN=$(generate_secret)
            echo "api_key=$API_KEY" >> $GITHUB_OUTPUT
            echo "callback_token=$CALLBACK_TOKEN" >> $GITHUB_OUTPUT
            echo "‚úÖ Generated API keys"
          fi
          
          echo "rotation_timestamp=$(date -u +'%Y-%m-%dT%H:%M:%SZ')" >> $GITHUB_OUTPUT

      - name: Backup Current Secrets
        run: |
          NAMESPACE="${{ github.event.inputs.namespace || 'dev' }}"
          BACKUP_DIR="secrets/backups"
          TIMESTAMP=$(date +%Y%m%d-%H%M%S)
          
          mkdir -p "$BACKUP_DIR"
          
          # Backup existing sealed secrets
          if [[ -d "secrets/" ]]; then
            cp -r secrets/*.yaml "$BACKUP_DIR/backup-$TIMESTAMP/" 2>/dev/null || true
            echo "‚úÖ Backed up current secrets to $BACKUP_DIR/backup-$TIMESTAMP/"
          fi

      - name: Create SealedSecret for FreshBonds
        if: steps.generate.outputs.jwt_secret != ''
        run: |
          NAMESPACE="${{ github.event.inputs.namespace || 'dev' }}"
          JWT_SECRET="${{ steps.generate.outputs.jwt_secret }}"
          DB_PASSWORD="${{ steps.generate.outputs.db_password }}"
          API_KEY="${{ steps.generate.outputs.api_key }}"
          CALLBACK_TOKEN="${{ steps.generate.outputs.callback_token }}"
          
          echo "üìù Creating sealed secret for freshbonds..."
          
          # Create temporary secret manifest
          cat > /tmp/freshbonds-secret.yaml <<EOF
          apiVersion: v1
          kind: Secret
          metadata:
            name: freshbonds-secret
            namespace: $NAMESPACE
            annotations:
              rotated-at: "${{ steps.generate.outputs.rotation_timestamp }}"
              rotated-by: "github-actions"
          type: Opaque
          stringData:
            JWT_SECRET: "$JWT_SECRET"
            MONGODB_URI: "${{ secrets.MONGODB_URI }}"
          EOF
          
          # Add optional secrets if generated
          if [[ -n "$DB_PASSWORD" ]]; then
            echo "  DB_PASSWORD: \"$DB_PASSWORD\"" >> /tmp/freshbonds-secret.yaml
          fi
          
          if [[ -n "$API_KEY" ]]; then
            echo "  API_KEY: \"$API_KEY\"" >> /tmp/freshbonds-secret.yaml
          fi
          
          if [[ -n "$CALLBACK_TOKEN" ]]; then
            echo "  CALLBACK_TOKEN: \"$CALLBACK_TOKEN\"" >> /tmp/freshbonds-secret.yaml
          fi
          
          # Get sealed secrets controller public key
          # If cluster is accessible, fetch from cluster
          if kubectl get ns sealed-secrets &>/dev/null; then
            echo "üîë Fetching public key from cluster..."
            kubectl get secret -n sealed-secrets sealed-secrets-key -o jsonpath='{.data.tls\.crt}' | base64 -d > /tmp/sealed-secrets.crt
            
            # Create sealed secret
            kubeseal --format=yaml --cert=/tmp/sealed-secrets.crt \
              < /tmp/freshbonds-secret.yaml \
              > secrets/freshbonds-secret.yaml
          else
            # If cluster not accessible, use stored public key
            echo "‚ö†Ô∏è Cluster not accessible, using stored public key"
            
            if [[ -f "secrets/sealed-secrets-public-key.crt" ]]; then
              kubeseal --format=yaml --cert=secrets/sealed-secrets-public-key.crt \
                < /tmp/freshbonds-secret.yaml \
                > secrets/freshbonds-secret.yaml
            else
              echo "‚ùå No public key available. Please add sealed-secrets-public-key.crt to secrets/ directory"
              echo "   Get it with: kubectl get secret -n sealed-secrets sealed-secrets-key -o jsonpath='{.data.tls\.crt}' | base64 -d > sealed-secrets-public-key.crt"
              exit 1
            fi
          fi
          
          echo "‚úÖ Created sealed secret: secrets/freshbonds-secret.yaml"
          
          # Clean up temporary files
          rm -f /tmp/freshbonds-secret.yaml /tmp/sealed-secrets.crt

      - name: Update Secret Rotation Log
        run: |
          NAMESPACE="${{ github.event.inputs.namespace || 'dev' }}"
          SECRET_TYPE="${{ github.event.inputs.secret_type || 'all' }}"
          TIMESTAMP="${{ steps.generate.outputs.rotation_timestamp }}"
          
          mkdir -p secrets/rotation-logs
          
          cat >> secrets/rotation-logs/rotation-history.md <<EOF
          
          ## Rotation: $TIMESTAMP
          - **Namespace:** $NAMESPACE
          - **Secret Type:** $SECRET_TYPE
          - **Triggered By:** ${{ github.actor }}
          - **Workflow Run:** ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}
          - **Commit:** ${{ github.sha }}
          
          EOF
          
          echo "‚úÖ Updated rotation log"

      - name: Configure Git
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

      - name: Commit and Push Changes
        run: |
          NAMESPACE="${{ github.event.inputs.namespace || 'dev' }}"
          TIMESTAMP="${{ steps.generate.outputs.rotation_timestamp }}"
          
          git add secrets/
          
          if git diff --staged --quiet; then
            echo "‚ÑπÔ∏è No changes to commit"
            exit 0
          fi
          
          git commit -m "chore: rotate secrets for $NAMESPACE [skip ci]

          Rotation timestamp: $TIMESTAMP
          Triggered by: ${{ github.actor }}
          
          ‚ö†Ô∏è Previous secrets backed up
          üîÑ ArgoCD will sync new secrets automatically"
          
          git push origin main
          
          echo "‚úÖ Secrets rotated and pushed to repository"

      - name: Trigger Application Restart
        run: |
          if [[ -n "${{ secrets.KUBECONFIG }}" ]]; then
            NAMESPACE="${{ github.event.inputs.namespace || 'dev' }}"
            
            echo "üîÑ Triggering rolling restart of applications..."
            
            # Restart deployments to pick up new secrets
            kubectl rollout restart deployment/freshbonds -n $NAMESPACE || echo "‚ö†Ô∏è Could not restart freshbonds"
            kubectl rollout restart deployment/api-gateway -n $NAMESPACE || echo "‚ö†Ô∏è Could not restart api-gateway"
            kubectl rollout restart deployment/user-service -n $NAMESPACE || echo "‚ö†Ô∏è Could not restart user-service"
            kubectl rollout restart deployment/product-service -n $NAMESPACE || echo "‚ö†Ô∏è Could not restart product-service"
            
            echo "‚úÖ Applications will restart with new secrets"
          else
            echo "‚ö†Ô∏è KUBECONFIG not configured, skipping application restart"
          fi

      - name: Verify Deployment Health
        run: |
          if [[ -n "${{ secrets.KUBECONFIG }}" ]]; then
            NAMESPACE="${{ github.event.inputs.namespace || 'dev' }}"
            
            echo "üè• Waiting for deployments to be ready..."
            
            # Wait for deployments (with timeout)
            kubectl rollout status deployment/freshbonds -n $NAMESPACE --timeout=5m || echo "‚ö†Ô∏è freshbonds rollout timed out"
            kubectl rollout status deployment/api-gateway -n $NAMESPACE --timeout=5m || echo "‚ö†Ô∏è api-gateway rollout timed out"
            kubectl rollout status deployment/user-service -n $NAMESPACE --timeout=5m || echo "‚ö†Ô∏è user-service rollout timed out"
          kubectl rollout status deployment/product-service -n $NAMESPACE --timeout=5m || echo "‚ö†Ô∏è product-service rollout timed out"
          
          echo ""
          echo "üìä Deployment Status:"
          kubectl get deployments -n $NAMESPACE

      - name: Send Notification
        if: always()
        run: |
          NAMESPACE="${{ github.event.inputs.namespace || 'dev' }}"
          STATUS="${{ job.status }}"
          
          if [[ "$STATUS" == "success" ]]; then
            EMOJI="‚úÖ"
            MESSAGE="Secret rotation completed successfully"
          else
            EMOJI="‚ùå"
            MESSAGE="Secret rotation failed"
          fi
          
          cat >> $GITHUB_STEP_SUMMARY <<EOF
          # $EMOJI Secret Rotation Summary
          
          **Namespace:** $NAMESPACE
          **Status:** $MESSAGE
          **Timestamp:** ${{ steps.generate.outputs.rotation_timestamp }}
          **Triggered By:** ${{ github.actor }}
          
          ## Actions Taken
          - ‚úÖ New secrets generated
          - ‚úÖ Previous secrets backed up
          - ‚úÖ SealedSecrets created and committed
          - ‚úÖ Applications restarted (if cluster accessible)
          
          ## Next Steps
          - ArgoCD will automatically sync the new sealed secrets
          - Monitor application health after rotation
          - Previous secrets backed up in secrets/backups/
          
          ---
          *Automated secret rotation workflow*
          EOF

      - name: Send PagerDuty Alert on Failure
        if: failure()
        run: |
          if [[ -n "${{ secrets.PAGERDUTY_INTEGRATION_KEY }}" ]]; then
            curl -X POST https://events.pagerduty.com/v2/enqueue \
              -H 'Content-Type: application/json' \
              -d '{
                "routing_key": "${{ secrets.PAGERDUTY_INTEGRATION_KEY }}",
                "event_action": "trigger",
                "payload": {
                  "summary": "Secret Rotation Failed - ${{ github.event.inputs.namespace || 'dev' }}",
                  "severity": "error",
                  "source": "GitHub Actions",
                "custom_details": {
                  "namespace": "${{ github.event.inputs.namespace || 'dev' }}",
                  "secret_type": "${{ github.event.inputs.secret_type || 'all' }}",
                  "workflow_url": "${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}"
                }
              }
            }'
